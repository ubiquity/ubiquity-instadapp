{
  "language": "Solidity",
  "sources": {
    "contracts/common/basic.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport { TokenInterface } from \"./interfaces.sol\";\nimport { Stores } from \"./stores.sol\";\nimport { DSMath } from \"./math.sol\";\n\nabstract contract Basic is DSMath, Stores {\n\n    function convert18ToDec(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = (_amt / 10 ** (18 - _dec));\n    }\n\n    function convertTo18(uint _dec, uint256 _amt) internal pure returns (uint256 amt) {\n        amt = mul(_amt, 10 ** (18 - _dec));\n    }\n\n    function getTokenBal(TokenInterface token) internal view returns(uint _amt) {\n        _amt = address(token) == ethAddr ? address(this).balance : token.balanceOf(address(this));\n    }\n\n    function getTokensDec(TokenInterface buyAddr, TokenInterface sellAddr) internal view returns(uint buyDec, uint sellDec) {\n        buyDec = address(buyAddr) == ethAddr ?  18 : buyAddr.decimals();\n        sellDec = address(sellAddr) == ethAddr ?  18 : sellAddr.decimals();\n    }\n\n    function encodeEvent(string memory eventName, bytes memory eventParam) internal pure returns (bytes memory) {\n        return abi.encode(eventName, eventParam);\n    }\n\n    function approve(TokenInterface token, address spender, uint256 amount) internal {\n        try token.approve(spender, amount) {\n\n        } catch {\n            token.approve(spender, 0);\n            token.approve(spender, amount);\n        }\n    }\n\n    function changeEthAddress(address buy, address sell) internal pure returns(TokenInterface _buy, TokenInterface _sell){\n        _buy = buy == ethAddr ? TokenInterface(wethAddr) : TokenInterface(buy);\n        _sell = sell == ethAddr ? TokenInterface(wethAddr) : TokenInterface(sell);\n    }\n\n    function convertEthToWeth(bool isEth, TokenInterface token, uint amount) internal {\n        if(isEth) token.deposit{value: amount}();\n    }\n\n    function convertWethToEth(bool isEth, TokenInterface token, uint amount) internal {\n       if(isEth) {\n            approve(token, address(token), amount);\n            token.withdraw(amount);\n        }\n    }\n}\n"
    },
    "contracts/common/interfaces.sol": {
      "content": "pragma solidity ^0.7.0;\n\ninterface TokenInterface {\n    function approve(address, uint256) external;\n    function transfer(address, uint) external;\n    function transferFrom(address, address, uint) external;\n    function deposit() external payable;\n    function withdraw(uint) external;\n    function balanceOf(address) external view returns (uint);\n    function decimals() external view returns (uint);\n}\n\ninterface MemoryInterface {\n    function getUint(uint id) external returns (uint num);\n    function setUint(uint id, uint val) external;\n}\n\ninterface InstaMapping {\n    function cTokenMapping(address) external view returns (address);\n    function gemJoinMapping(bytes32) external view returns (address);\n}\n\ninterface AccountInterface {\n    function enable(address) external;\n    function disable(address) external;\n    function isAuth(address) external view returns (bool);\n}\n"
    },
    "contracts/common/stores.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport { MemoryInterface, InstaMapping } from \"./interfaces.sol\";\n\n\nabstract contract Stores {\n\n  /**\n   * @dev Return ethereum address\n   */\n  address constant internal ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /**\n   * @dev Return Wrapped ETH address\n   */\n  address constant internal wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n  /**\n   * @dev Return memory variable address\n   */\n  MemoryInterface constant internal instaMemory = MemoryInterface(0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F);\n\n  /**\n   * @dev Return InstaDApp Mapping Addresses\n   */\n  InstaMapping constant internal instaMapping = InstaMapping(0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88);\n\n  /**\n   * @dev Get Uint value from InstaMemory Contract.\n   */\n  function getUint(uint getId, uint val) internal returns (uint returnVal) {\n    returnVal = getId == 0 ? val : instaMemory.getUint(getId);\n  }\n\n  /**\n  * @dev Set Uint value in InstaMemory Contract.\n  */\n  function setUint(uint setId, uint val) virtual internal {\n    if (setId != 0) instaMemory.setUint(setId, val);\n  }\n\n}\n"
    },
    "contracts/common/math.sol": {
      "content": "pragma solidity ^0.7.0;\n\nimport { SafeMath } from \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract DSMath {\n  uint constant WAD = 10 ** 18;\n  uint constant RAY = 10 ** 27;\n\n  function add(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(x, y);\n  }\n\n  function sub(uint x, uint y) internal virtual pure returns (uint z) {\n    z = SafeMath.sub(x, y);\n  }\n\n  function mul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.mul(x, y);\n  }\n\n  function div(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.div(x, y);\n  }\n\n  function wmul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\n  }\n\n  function wdiv(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\n  }\n\n  function rdiv(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\n  }\n\n  function rmul(uint x, uint y) internal pure returns (uint z) {\n    z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\n  }\n\n  function toInt(uint x) internal pure returns (int y) {\n    y = int(x);\n    require(y >= 0, \"int-overflow\");\n  }\n\n  function toRad(uint wad) internal pure returns (uint rad) {\n    rad = mul(wad, 10 ** 27);\n  }\n\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/connector/helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport {TokenInterface} from \"../common/interfaces.sol\";\nimport {DSMath} from \"../common/math.sol\";\nimport {Basic} from \"../common/basic.sol\";\n\nabstract contract Helpers is DSMath, Basic {\n  /**\n   * @dev Ubiquity Algorithmic Dollar Manager Address\n   */\n  address internal constant UbiquityAlgorithmicDollarManager = 0x4DA97a8b831C345dBe6d16FF7432DF2b7b776d98;\n\n  /**\n   * @dev DAI Address\n   */\n  address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\n  /**\n   * @dev USDC Address\n   */\n  address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n  /**\n   * @dev USDT Address\n   */\n  address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n  /**\n   * @dev Curve 3CRV Token Address\n   */\n  address internal constant CRV3 = 0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490;\n\n  /**\n   * @dev Curve 3Pool Address\n   */\n  address internal constant Pool3 = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;\n}\n"
    },
    "contracts/connector/main.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\npragma abicoder v2;\n\n/**\n * @title Ubiquity.\n * @dev Ubiquity Dollar (uAD).\n */\n\nimport {TokenInterface, MemoryInterface} from \"../common/interfaces.sol\";\nimport {Stores} from \"../common/stores.sol\";\nimport {SafeMath} from \"../common/math.sol\";\nimport {IUbiquityBondingV2, IUbiquityMetaPool, IUbiquity3Pool, IUbiquityAlgorithmicDollarManager} from \"./interfaces.sol\";\nimport {Helpers} from \"./helpers.sol\";\nimport {Events} from \"./events.sol\";\n\ncontract ConnectV2Ubiquity is Helpers, Events {\n  string public constant name = \"Ubiquity-v1\";\n\n  /**\n   * @dev Deposit into Ubiquity protocol\n   * @notice 3POOL (DAI / USDC / USDT) => METAPOOL (3CRV / uAD) => uAD3CRV-f => Ubiquity BondingShare\n   * @notice STEP 1 : 3POOL (DAI / USDC / USDT) => 3CRV\n   * @notice STEP 2 : METAPOOL(3CRV / UAD) => uAD3CRV-f\n   * @notice STEP 3 : uAD3CRV-f => Ubiquity BondingShare\n   * @param token Token deposited : DAI, USDC, USDT, 3CRV, uAD or uAD3CRV-f\n   * @param amount Amount of tokens to deposit (For max: `uint256(-1)`)\n   * @param durationWeeks Duration in weeks tokens will be locked (4-208)\n   * @param getId ID to retrieve amt.\n   * @param setId ID stores the amount of tokens deposited.\n   */\n  function deposit(\n    address token,\n    uint256 amount,\n    uint256 durationWeeks,\n    uint256 getId,\n    uint256 setId\n  ) external payable returns (string memory _eventName, bytes memory _eventParam) {\n    address UAD = IUbiquityAlgorithmicDollarManager(UbiquityAlgorithmicDollarManager).dollarTokenAddress();\n    address UAD3CRVf = IUbiquityAlgorithmicDollarManager(UbiquityAlgorithmicDollarManager).stableSwapMetaPoolAddress();\n\n    require(\n      token == DAI || token == USDC || token == USDT || token == UAD || token == CRV3 || token == UAD3CRVf,\n      \"Invalid token: must be DAI, USDC, USDT, uAD, 3CRV or uAD3CRV-f\"\n    );\n\n    uint256 _amount = getUint(getId, amount);\n    uint256 _lpAmount;\n\n    // Full balance if amount = -1\n    if (_amount == uint256(-1)) {\n      _amount = getTokenBal(TokenInterface(token));\n    }\n\n    // STEP 1 : SwapTo3CRV : Deposit DAI, USDC or USDT into 3Pool to get 3Crv LPs\n    if (token == DAI || token == USDC || token == USDT) {\n      uint256[3] memory amounts1;\n\n      if (token == DAI) amounts1[0] = _amount;\n      else if (token == USDC) amounts1[1] = _amount;\n      else if (token == USDT) amounts1[2] = _amount;\n\n      approve(TokenInterface(token), Pool3, _amount);\n      IUbiquity3Pool(Pool3).add_liquidity(amounts1, 0);\n    }\n\n    // STEP 2 : ProvideLiquidityToMetapool : Deposit in uAD3CRV pool to get uAD3CRV-f LPs\n    if (token == DAI || token == USDC || token == USDT || token == UAD || token == CRV3) {\n      uint256[2] memory amounts2;\n      address token2 = token;\n      uint256 _amount2;\n\n      if (token == UAD) {\n        _amount2 = _amount;\n        amounts2[0] = _amount2;\n      } else {\n        if (token == CRV3) {\n          _amount2 = _amount;\n        } else {\n          token2 = CRV3;\n          _amount2 = getTokenBal(TokenInterface(token2));\n        }\n        amounts2[1] = _amount2;\n      }\n\n      approve(TokenInterface(token2), UAD3CRVf, _amount2);\n      _lpAmount = IUbiquityMetaPool(UAD3CRVf).add_liquidity(amounts2, 0);\n    }\n\n    // STEP 3 : Farm/ApeIn : Deposit uAD3CRV-f LPs into UbiquityBondingV2 and get Ubiquity Bonding Shares\n    if (token == UAD3CRVf) {\n      _lpAmount = _amount;\n    }\n\n    address Bonding = IUbiquityAlgorithmicDollarManager(UbiquityAlgorithmicDollarManager).bondingContractAddress();\n    approve(TokenInterface(UAD3CRVf), Bonding, _lpAmount);\n    uint256 bondingShareId = IUbiquityBondingV2(Bonding).deposit(_lpAmount, durationWeeks);\n\n    setUint(setId, bondingShareId);\n\n    _eventName = \"Deposit(address,address,uint256,uint256,uint256,uint256,uint256,uint256)\";\n    _eventParam = abi.encode(address(this), token, amount, _lpAmount, durationWeeks, bondingShareId, getId, setId);\n  }\n}\n"
    },
    "contracts/connector/interfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport {TokenInterface} from \"../common/interfaces.sol\";\n\ninterface IUbiquityBondingV2 {\n  function deposit(uint256 lpAmount, uint256 durationWeeks) external returns (uint256 bondingShareId);\n}\n\ninterface IUbiquityMetaPool {\n  function add_liquidity(uint256[2] memory _amounts, uint256 _min_mint_amount) external returns (uint256);\n}\n\ninterface IUbiquity3Pool {\n  function add_liquidity(uint256[3] calldata _amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IUbiquityAlgorithmicDollarManager {\n  function dollarTokenAddress() external returns (address);\n\n  function stableSwapMetaPoolAddress() external returns (address);\n\n  function bondingContractAddress() external returns (address);\n}\n"
    },
    "contracts/connector/events.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ncontract Events {\n    event Deposit(\n        address indexed userAddress,\n        address indexed token,\n        uint256 amount,\n        uint256 lpAmount,\n        uint256 durationWeeks,\n        uint256 indexed bondingShareId,\n        uint256 getId,\n        uint256 setId\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}